{%- import "enum.tera" as enum -%}
{%- import "struct.tera" as struct -%}
{%- import "default.tera" as default -%}
{%- import "error.tera" as error -%}
#![allow(unused_imports, dead_code)]

//! API auto-generated by apigen

use std::{
    collections::HashMap,
    fmt::{Debug, Display},
};

use serde::{Deserialize, Serialize};

use actix_web::{
    http::StatusCode,
    middleware::{NormalizePath, TrailingSlash},
    web, App, HttpRequest, HttpResponse, HttpServer, ResponseError,
};

use actix_web_prom::{PrometheusMetrics, PrometheusMetricsBuilder};

use async_trait::async_trait;

// Defaults
// -------------------------------
{%- for model in defaults %}
{{ default::render(model=model) }}
{%- endfor %}

// Enums
// -------------------------------
{%- for model in enums %}
{{ enum::render(model=model) }}
{%- endfor %}

// Struct
// -------------------------------
{%- for model in structs %}
{{ struct::render(model=model) }}
{%- endfor %}

// Error with details
// -------------------------------

/// Create detailed errors with ease
#[macro_export]
macro_rules! detailed {
    ($err:expr,$msg:expr) => {
        $crate::server::api::Detailed {
            error: $err,
            details: $msg.to_string(),
        }
    };
}

/// Bails with detailed api error
#[macro_export]
macro_rules! apibail {
    ($err:expr,$msg:expr) => {
        return Err($crate::server::api::Detailed {
            error: $err,
            details: $msg.to_string(),
        })
    };
}

pub trait StatusCoded {
    fn status_code(&self) -> StatusCode;
}

#[derive(Debug)]
pub struct Detailed<E> {
    pub error: E,
    pub details: String,
}

impl<E: Display> Display for Detailed<E> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}. Reason: {}", self.error, self.details)
    }
}

impl<E: Display + Debug> std::error::Error for Detailed<E> {}

impl<E: Display + Debug> ResponseError for Detailed<E>
where
    E: StatusCoded,
{
    fn status_code(&self) -> StatusCode {
        self.error.status_code()
    }
}

/// Converts some result to Result with detailed api error
pub trait ApiErr<T, E> {
    /// Wrap the error value with additional context.
    fn apierr<C>(self, err: C) -> Result<T, Detailed<C>>
    where
        C: Display + Send + Sync + 'static;
}

impl<T, E> ApiErr<T, E> for Result<T, E>
where
    E: Debug + Send + Sync + 'static,
{
    fn apierr<C>(self, err: C) -> Result<T, Detailed<C>>
    where
        C: Display + Send + Sync + 'static,
    {
        // Not using map_err to save 2 useless frames off the captured backtrace
        // in ext_context.
        match self {
            Ok(ok) => Ok(ok),
            Err(original_error) => Err(Detailed {
                error: err,
                details: format!("{:?}", original_error),
            }),
        }
    }
}

// Error
// -------------------------------
{%- for model in errors %}
{{ error::render(model=model) }}
{%- endfor %}

// Api service
// -------------------------------

#[async_trait(?Send)]
pub trait ApiService<S>
where
    S: Send + Sync + 'static,
{
    {%- for method in methods %}
    {{- method.doc | comment | newline | indent(n=4) }}
    async fn {{method.operation_id}}(
        data: web::Data<S>,
        {%- for arg in method.args %}
        {{arg.name}}: {{arg.type_}},
        {%- endfor %}
    ) -> {{method.response_type}};
    {%- endfor %}
}

// Run service function (+ helper functions)
// -----------------------------------------

{%- for include in static_includes %}
static {{include.title}}: &str = include_str!({{include.file_path | quote}});
{%- endfor %}

{%- for static_string in static_strings %}
async fn {{static_string.title}}() -> String {
    {{static_string.data}}.to_string()
}
{%- endfor %}

{%- for static_html in static_htmls %}
async fn {{static_html.title}}() -> HttpResponse {
    HttpResponse::build(StatusCode::OK)
        .content_type("text/html; charset=utf-8")
        .body({{static_html.data}})
}
{%- endfor %}

{%- for redirect in redirects %}
async fn {{redirect.title}}() -> HttpResponse {
    HttpResponse::build(StatusCode::TEMPORARY_REDIRECT)
        .append_header(("Location", {{redirect.target | quote}}))
        .body("")
}
{%- endfor %}

// Tells that service is alive
async fn health() -> HttpResponse {
    HttpResponse::Ok().finish()
}


/// Just make scope - can be used for manual server creation
/// And to combine with other scopes
pub fn make_scope<T, S>(prometheus: PrometheusMetrics) -> actix_web::Scope
where
    T: ApiService<S> + 'static,
    S: Send + Sync + 'static,
{
    use web::{delete, get, post};

    let api = web::scope("")
        {%- for path in paths %}
        .route({{path.path | quote}}, {{path.method}}().to(T::{{path.operation_id}}))
        {%- endfor %}
        .wrap(prometheus);

    web::scope("")
        // Aux services
        .route("/health", get().to(health))
        // Static paths
        {%- for static_service in static_services %}
        .route({{static_service.path | quote}}, {{static_service.method}}().to({{static_service.target}}))
        {%- endfor %}
        // Server routes
        .service(api)
}
